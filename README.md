# Go-concurrency

## [Использование go-подпрограмм для выполнения заданий](https://github.com/MukhinIvan/go-concurrency/tree/main/01_using_a_goroutine/main.go)

**Сопрограммой** может быть любая функция, которая вызывается с помощью ключевого слова `go`.

В программе используются следующие библиотеки:

* `fmt` - для вывода строк в консоль (`fmt.Println()`);
* `io` - для интерфейсов чтения и записи (`io.Reader`, `io.Writer`), а также для копирования данных из одного потока в другой (`io.Copy()`);
* `os` - для стандартных потоков ввода-вывода (`os.Stdout` и `os.Stdin`);
* `time` - для задержки на 30 секунд (`time.Sleep()`).

## [Использование замыканий сопрограмм](https://github.com/MukhinIvan/go-concurrency/tree/main/02_an_anonymous_goroutine/main.go)

Объявляем анонимную функцию и вызываем ее как сопрограмму.

В программе используются следующие библиотеки:

* `fmt` - для вывода строк в консоль (`fmt.Println()`);
* `runtime` - для `runtime.Gosched()`.

Чтобы у планировщика была возможность запустить сопрограмму до того, как функция `main` завершит программу, мы вызываем `runtime.Gosched()`, давая среде выполнения шанс запустить сопрограмму до завершения программы.

Если сопрограмма выполняет запрос к базе данных, простого вызова `runtime.Gosched` может быть недостаточно, чтобы обеспечить завершение запросов другими сопрограммами. Они могут находиться в состоянии ожидания ответа от базы данных, что вынудит планировщик продолжить выполнение текущей функции.
